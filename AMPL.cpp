/*
* Argus Open Source
* Software to apply Statistical Disclosure Control techniques
* 
* Copyright 2014 Statistics Netherlands
* 
* This program is free software; you can redistribute it and/or 
* modify it under the terms of the European Union Public Licence 
* (EUPL) version 1.1, as published by the European Commission.
* 
* You can find the text of the EUPL v1.1 on
* https://joinup.ec.europa.eu/software/page/eupl/licence-eupl
* 
* This software is distributed on an "AS IS" basis without 
* warranties or conditions of any kind, either express or implied.
*/

#include <cstdio>
#include <cmath>

#include "AMPL.h"

// The AMPL format is a special way to describe a table. It is used in networking.
// Only 2 dimensional, non hierarchical tabels can be described this way.
 
bool CAMPL::WriteTableInAMPL(CTable *tab, CVariable *var, FILE *fd)
{
	long rows,columns,i,No_Unsafe=0, tempstatus,j, No_Protected = 0;
	CVariable *tempvar, *RespVar, *CostVar;
	long ScaledCost;
	CDataCell *dc;
	long *ind;
	double MaxCost = tab->GetCell(0L)->GetCost(tab->Lambda);
	RespVar = &(var[tab->ResponseVarnr]);
	CostVar = &(var[tab->CostVarnr]);
	ind = new long[tab->nDim];
	double dRoundConst = (0.5)/pow(10,RespVar->nDec);
	double UPL, LPL, Sliding, Capacity;
	UPL=0; LPL=0; Sliding = 0; Capacity = 0;
	fprintf(fd,"%s\n", "# generated by Tau_Argus");
	fprintf(fd,"%s\n", "# Not too sure something Jordi wants");
	fprintf(fd,"\n");
	fprintf(fd,"%s\n", "#m= number of rows of the table (without marginal row)");
	tempvar = &(var[tab->ExplVarnr[0]]);
/*	string tempcode;
	for (i=0; i<tempvar->nCode; i++) 
	{
		tempcode = tempvar->sCode[i];
	}*/
	rows = tempvar->nCode-1;
	fprintf(fd, "%s %ld %s\n", "param m := ", rows, ";");
	tempvar = &(var[tab->ExplVarnr[1]]);
	columns = tempvar->nCode-1;
	fprintf(fd,"\n");
	fprintf(fd,"%s\n", "#m= number of columns of the table (without marginal columns)");

	fprintf(fd,"%s %ld %s\n","param p := ", columns, ";");
	fprintf(fd,"\n");
	
	for(i=0; i<tab->nCell; i++) {
		
		tempstatus = tab->GetCell(i)->GetStatus();
		if ((tempstatus == CS_UNSAFE_FREQ) || (tempstatus == CS_UNSAFE_PEEP) ||
				( tempstatus == CS_UNSAFE_RULE) || (tempstatus == CS_UNSAFE_MANUAL) || 
				(tempstatus == CS_UNSAFE_SINGLETON) || (tempstatus == CS_UNSAFE_ZERO)) No_Unsafe++;
		if (tempstatus == CS_PROTECT_MANUAL) No_Protected++;
	}

	fprintf(fd,"%s\n", "#p= number of primary suppression cells");

	fprintf(fd,"%s %ld %s\n","param p := ", No_Unsafe, ";");
	fprintf(fd,"\n");
	fprintf(fd,"%s\n", "#row, column, low_pl and upp_pl of each primary suppression cell");
	fprintf(fd,"%s\n","param: 		 p_r 		 p_c 		 p_lpl 		 p_upl:=");

	long volgnum =  1;
	for(i=0; i<tab->nCell; i++) {
		
		tempstatus = tab->GetCell(i)->GetStatus();
		if ((tempstatus == CS_UNSAFE_FREQ) || (tempstatus == CS_UNSAFE_PEEP) ||
			( tempstatus == CS_UNSAFE_RULE) ||  (tempstatus == CS_UNSAFE_MANUAL) ||
			(tempstatus == CS_UNSAFE_SINGLETON) || (tempstatus == CS_UNSAFE_ZERO)) {
			dc = tab->GetCell(i);
			tab->GetIndicesFromCellNr(i,ind);
			fprintf(fd,"%ld", volgnum); volgnum++;
			for (j=0; j<tab->nDim; j++) {
				// Think about this if ind[j] = 0; 
				if (ind[j] == 0) {
					tempvar = &(var[tab->ExplVarnr[j]]);
					fprintf(fd,"   %d", tempvar->nCode);
				}
				else {
					fprintf (fd,"   %ld", ind[j]);
				}
			}
			//print lpl en upl
			
			/*dc->GetProtectionLevel(
			tab->SafetyRule, tab->ManualSafetyPerc, 
			tab->CellFreqSafetyPerc,
			tab->HoldingFreqSafetyPerc,
			tab->PeepSafetyRangePercCell,
			tab->PeepSafetyRangePercHolding,
			tab->SingletonSafetyRangePerc,
			tab->ZeroSafetyRange,
			tab->SafeMinRec, 
			tab->SafeMinHoldings,
			tab->ApplyHolding,
			tab->ApplyWeight, 
			tab->DominancePercCell_1,tab->DominancePercCell_2,
			tab->DominancePercHolding_1, tab->DominancePercHolding_2,
			tab->DominanceNumberCell_1,tab->DominanceNumberCell_2,
			tab->DominanceNumberHolding_1, tab->DominanceNumberHolding_2,
			tab->PQ_PCell_1, tab->PQ_PCell_2, tab->PQ_PHolding_1, tab->PQ_PHolding_2,
			tab->PQ_QCell_1, tab->PQ_QCell_2, tab->PQ_QHolding_1, tab->PQ_QHolding_2,
			tab->PQ_NCell_1, tab->PQ_NCell_2, tab->PQ_NHolding_1, tab->PQ_NHolding_2,
			&UPL, &LPL, &Sliding, &Capacity);*/
			UPL = dc->GetUpperProtectionLevel();
			LPL = dc->GetLowerProtectionLevel();
			if (dc->GetResp() - LPL - dRoundConst > 0 ) LPL = LPL + dRoundConst;
			fprintf(fd, "    %f    %f\n", LPL , UPL + dRoundConst);

		}
	}
	fprintf(fd,"%s\n", ";");
	fprintf(fd,"\n");

	// Now write the protected cells;
	fprintf(fd, "%s\n", "#p= number of protected cells");
	fprintf(fd,"%s %ld %s\n","param p := ", No_Protected, ";");


	fprintf(fd,"\n");
	fprintf(fd,"%s\n", "#row, column of each protectedcell");
	fprintf(fd,"%s\n","param: 		 p_r 		 p_c 	");

	for(i=0; i<tab->nCell; i++) {
		
		tempstatus = tab->GetCell(i)->GetStatus();
		if (tempstatus == CS_PROTECT_MANUAL) {

			dc = tab->GetCell(i);
			tab->GetIndicesFromCellNr(i,ind);
			for (j=0; j<tab->nDim; j++) {
				// Think about this if ind[j] = 0; 
				if (ind[j] == 0) {
					tempvar = &(var[tab->ExplVarnr[j]]);
					fprintf(fd,"   %d", tempvar->nCode);
				}
				else {
					fprintf (fd,"   %ld", ind[j]);
				}
			}
			fprintf(fd,"\n");
		}
	}

	fprintf(fd,"%s\n", ";");
	fprintf(fd,"\n");


	///
	fprintf(fd, "%s\n", "#(m+1)*(n+1) table values (including marginals)");
	fprintf(fd,"%s\n","param a :=");
	//start printing cells

	for(i=0; i<tab->nCell; i++) {
		dc = tab->GetCell(i);
		tab->GetIndicesFromCellNr(i,ind);
		for (j=0; j<tab->nDim; j++) {
				// Think about this if ind[j] = 0; 
				if (ind[j] == 0) {
					tempvar = &(var[tab->ExplVarnr[j]]);
					fprintf(fd,"    %d", tempvar->nCode);
				}
				else {
					fprintf (fd,"   %ld", ind[j]);
				}
		}
		ScaledCost = (long) (dc->GetCost(tab->Lambda) * tab->MaxScaledCost / MaxCost + .5);
		if (ScaledCost == 0) ScaledCost = 1;
			
		fprintf(fd, "    %.*f		%ld\n", (int)RespVar->nDec,  dc->GetResp(),ScaledCost);
	}

	fprintf(fd,"%s\n", ";");


	delete[] ind;
	
	return true;
}

/*
bool CAMPL::WriteHierTableInAMPL(CTauArgCtrl *myptr, CTable *tab, CVariable *var, CSubCodeList *sublist, FILE *fd)
{
	long nsubtab;
	fprintf(fd, "%s\n", "#T = number of 2D tables");
//	nsubtab = myptr->
	fprintf (fd, "%s%d%s\n", "param T := ", nsubtab, ";");
	fprintf (fd, "%s\n", "#M = number of rows of each table (without marginal row)");
	fprintf (fd,"%s\n", "param M := ");

	return true;
}
*/
