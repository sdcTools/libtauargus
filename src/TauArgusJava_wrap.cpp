/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGJAVA
#define SWIGJAVA
#endif

#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1,
  SWIG_JavaIOException,
  SWIG_JavaRuntimeException,
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError,
  SWIG_JavaIllegalStateException,
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { SWIG_JavaIllegalStateException, "java/lang/IllegalStateException" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" }
  };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Java proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED) || defined(DEBUG_DIRECTOR_EXCEPTION) || defined(DEBUG_DIRECTOR_THREAD_NAME)
#include <iostream>
#endif

#include <exception>

#if defined(SWIG_JAVA_USE_THREAD_NAME)

#if !defined(SWIG_JAVA_GET_THREAD_NAME)
namespace Swig {
  SWIGINTERN int GetThreadName(char *name, size_t len);
}

#if defined(__linux__)

#include <sys/prctl.h>
SWIGINTERN int Swig::GetThreadName(char *name, size_t len) {
  (void)len;
#if defined(PR_GET_NAME)
  return prctl(PR_GET_NAME, (unsigned long)name, 0, 0, 0);
#else
  (void)name;
  return 1;
#endif
}

#elif defined(__unix__) || defined(__APPLE__)

#include <pthread.h>
SWIGINTERN int Swig::GetThreadName(char *name, size_t len) {
  return pthread_getname_np(pthread_self(), name, len);
}

#else

SWIGINTERN int Swig::GetThreadName(char *name, size_t len) {
  (void)len;
  (void)name;
  return 1;
}
#endif

#endif

#endif

namespace Swig {

  /* Java object wrapper */
  class JObjectWrapper {
  public:
    JObjectWrapper() : jthis_(NULL), weak_global_(true) {
    }

    ~JObjectWrapper() {
      jthis_ = NULL;
      weak_global_ = true;
    }

    bool set(JNIEnv *jenv, jobject jobj, bool mem_own, bool weak_global) {
      if (!jthis_) {
        weak_global_ = weak_global || !mem_own; // hold as weak global if explicitly requested or not owned
        if (jobj)
          jthis_ = weak_global_ ? jenv->NewWeakGlobalRef(jobj) : jenv->NewGlobalRef(jobj);
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> " << jthis_ << std::endl;
#endif
        return true;
      } else {
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> already set" << std::endl;
#endif
        return false;
      }
    }

    jobject get(JNIEnv *jenv) const {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::get(";
      if (jthis_)
        std::cout << jthis_;
      else
        std::cout << "null";
      std::cout << ") -> return new local ref" << std::endl;
#endif
      return (jthis_ ? jenv->NewLocalRef(jthis_) : jthis_);
    }

    void release(JNIEnv *jenv) {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::release(" << jthis_ << "): " << (weak_global_ ? "weak global ref" : "global ref") << std::endl;
#endif
      if (jthis_) {
        if (weak_global_) {
          if (jenv->IsSameObject(jthis_, NULL) == JNI_FALSE)
            jenv->DeleteWeakGlobalRef((jweak)jthis_);
        } else
          jenv->DeleteGlobalRef(jthis_);
      }

      jthis_ = NULL;
      weak_global_ = true;
    }

    /* Only call peek if you know what you are doing wrt to weak/global references */
    jobject peek() {
      return jthis_;
    }

    /* Java proxy releases ownership of C++ object, C++ object is now
       responsible for destruction (creates NewGlobalRef to pin Java proxy) */
    void java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      if (take_or_release) {  /* Java takes ownership of C++ object's lifetime. */
        if (!weak_global_) {
          jenv->DeleteGlobalRef(jthis_);
          jthis_ = jenv->NewWeakGlobalRef(jself);
          weak_global_ = true;
        }
      } else {
	/* Java releases ownership of C++ object's lifetime */
        if (weak_global_) {
          jenv->DeleteWeakGlobalRef((jweak)jthis_);
          jthis_ = jenv->NewGlobalRef(jself);
          weak_global_ = false;
        }
      }
    }

  private:
    /* pointer to Java object */
    jobject jthis_;
    /* Local or global reference flag */
    bool weak_global_;
  };

  /* Local JNI reference deleter */
  class LocalRefGuard {
    JNIEnv *jenv_;
    jobject jobj_;

    // non-copyable
    LocalRefGuard(const LocalRefGuard &);
    LocalRefGuard &operator=(const LocalRefGuard &);
  public:
    LocalRefGuard(JNIEnv *jenv, jobject jobj): jenv_(jenv), jobj_(jobj) {}
    ~LocalRefGuard() {
      if (jobj_)
        jenv_->DeleteLocalRef(jobj_);
    }
  };

  /* director base class */
  class Director {
    /* pointer to Java virtual machine */
    JavaVM *swig_jvm_;

  protected:
#if defined (_MSC_VER) && (_MSC_VER<1300)
    class JNIEnvWrapper;
    friend class JNIEnvWrapper;
#endif
    /* Utility class for managing the JNI environment */
    class JNIEnvWrapper {
      const Director *director_;
      JNIEnv *jenv_;
      int env_status;
    public:
      JNIEnvWrapper(const Director *director) : director_(director), jenv_(0), env_status(0) {
#if defined(__ANDROID__)
        JNIEnv **jenv = &jenv_;
#else
        void **jenv = (void **)&jenv_;
#endif
        env_status = director_->swig_jvm_->GetEnv((void **)&jenv_, JNI_VERSION_1_2);
        JavaVMAttachArgs args;
        args.version = JNI_VERSION_1_2;
        args.group = NULL;
        args.name = NULL;
#if defined(SWIG_JAVA_USE_THREAD_NAME)
        char thread_name[64];  // MAX_TASK_COMM_LEN=16 is hard-coded in the Linux kernel and MacOS has MAXTHREADNAMESIZE=64.
        if (Swig::GetThreadName(thread_name, sizeof(thread_name)) == 0) {
          args.name = thread_name;
#if defined(DEBUG_DIRECTOR_THREAD_NAME)
          std::cout << "JNIEnvWrapper: thread name: " << thread_name << std::endl;
        } else {
          std::cout << "JNIEnvWrapper: Couldn't set Java thread name" << std::endl;
#endif
        }
#endif
#if defined(SWIG_JAVA_ATTACH_CURRENT_THREAD_AS_DAEMON)
        // Attach a daemon thread to the JVM. Useful when the JVM should not wait for
        // the thread to exit upon shutdown. Only for jdk-1.4 and later.
        director_->swig_jvm_->AttachCurrentThreadAsDaemon(jenv, &args);
#else
        director_->swig_jvm_->AttachCurrentThread(jenv, &args);
#endif
      }
      ~JNIEnvWrapper() {
#if !defined(SWIG_JAVA_NO_DETACH_CURRENT_THREAD)
        // Some JVMs, eg jdk-1.4.2 and lower on Solaris have a bug and crash with the DetachCurrentThread call.
        // However, without this call, the JVM hangs on exit when the thread was not created by the JVM and creates a memory leak.
        if (env_status == JNI_EDETACHED)
          director_->swig_jvm_->DetachCurrentThread();
#endif
      }
      JNIEnv *getJNIEnv() const {
        return jenv_;
      }
    };

    /* Java object wrapper */
    JObjectWrapper swig_self_;

    /* Disconnect director from Java object */
    void swig_disconnect_director_self(const char *disconn_method) {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      jobject jobj = swig_self_.get(jenv);
      LocalRefGuard ref_deleter(jenv, jobj);
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "Swig::Director::disconnect_director_self(" << jobj << ")" << std::endl;
#endif
      if (jobj && jenv->IsSameObject(jobj, NULL) == JNI_FALSE) {
        jmethodID disconn_meth = jenv->GetMethodID(jenv->GetObjectClass(jobj), disconn_method, "()V");
        if (disconn_meth) {
#if defined(DEBUG_DIRECTOR_OWNED)
          std::cout << "Swig::Director::disconnect_director_self upcall to " << disconn_method << std::endl;
#endif
          jenv->CallVoidMethod(jobj, disconn_meth);
        }
      }
    }

  public:
    Director(JNIEnv *jenv) : swig_jvm_((JavaVM *) NULL), swig_self_() {
      /* Acquire the Java VM pointer */
      jenv->GetJavaVM(&swig_jvm_);
    }

    virtual ~Director() {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      swig_self_.release(jenv);
    }

    bool swig_set_self(JNIEnv *jenv, jobject jself, bool mem_own, bool weak_global) {
      return swig_self_.set(jenv, jself, mem_own, weak_global);
    }

    jobject swig_get_self(JNIEnv *jenv) const {
      return swig_self_.get(jenv);
    }

    // Change C++ object's ownership, relative to Java
    void swig_java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      swig_self_.java_change_ownership(jenv, jself, take_or_release);
    }
  };

  // Zero initialized bool array
  template<size_t N> class BoolArray {
    bool array_[N];
  public:
    BoolArray() {
      memset(array_, 0, sizeof(array_));
    }
    bool& operator[](size_t n) {
      return array_[n];
    }
    bool operator[](size_t n) const {
      return array_[n];
    }
  };

  // Utility classes and functions for exception handling.

  // Simple holder for a Java string during exception handling, providing access to a c-style string
  class JavaString {
  public:
    JavaString(JNIEnv *jenv, jstring jstr) : jenv_(jenv), jstr_(jstr), cstr_(0) {
      if (jenv_ && jstr_)
	cstr_ = (const char *) jenv_->GetStringUTFChars(jstr_, NULL);
    }

    ~JavaString() {
      if (jenv_ && jstr_ && cstr_)
	jenv_->ReleaseStringUTFChars(jstr_, cstr_);
    }

    const char *c_str(const char *null_string = "null JavaString") const {
      return cstr_ ? cstr_ : null_string;
    }

  private:
    // non-copyable
    JavaString(const JavaString &);
    JavaString &operator=(const JavaString &);

    JNIEnv *jenv_;
    jstring jstr_;
    const char *cstr_;
  };

  // Helper class to extract the exception message from a Java throwable
  class JavaExceptionMessage {
  public:
    JavaExceptionMessage(JNIEnv *jenv, jthrowable throwable) : message_(jenv, exceptionMessageFromThrowable(jenv, throwable)) {
    }

    // Return a C string of the exception message in the jthrowable passed in the constructor
    // If no message is available, null_string is return instead
    const char *message(const char *null_string = "Could not get exception message in JavaExceptionMessage") const {
      return message_.c_str(null_string);
    }

  private:
    // non-copyable
    JavaExceptionMessage(const JavaExceptionMessage &);
    JavaExceptionMessage &operator=(const JavaExceptionMessage &);

    // Get exception message by calling Java method Throwable.getMessage()
    static jstring exceptionMessageFromThrowable(JNIEnv *jenv, jthrowable throwable) {
      jstring jmsg = NULL;
      if (jenv && throwable) {
	jenv->ExceptionClear(); // Cannot invoke methods with any pending exceptions
	jclass throwclz = jenv->GetObjectClass(throwable);
	if (throwclz) {
	  // All Throwable classes have a getMessage() method, so call it to extract the exception message
	  jmethodID getMessageMethodID = jenv->GetMethodID(throwclz, "getMessage", "()Ljava/lang/String;");
	  if (getMessageMethodID)
	    jmsg = (jstring)jenv->CallObjectMethod(throwable, getMessageMethodID);
	}
	if (jmsg == NULL && jenv->ExceptionCheck())
	  jenv->ExceptionClear();
      }
      return jmsg;
    }

    JavaString message_;
  };

  // C++ Exception class for handling Java exceptions thrown during a director method Java upcall
  class DirectorException : public std::exception {
  public:

    // Construct exception from a Java throwable
    DirectorException(JNIEnv *jenv, jthrowable throwable) : jenv_(jenv), throwable_(throwable), classname_(0), msg_(0) {

      // Call Java method Object.getClass().getName() to obtain the throwable's class name (delimited by '/')
      if (jenv && throwable) {
	jenv->ExceptionClear(); // Cannot invoke methods with any pending exceptions
	jclass throwclz = jenv->GetObjectClass(throwable);
	if (throwclz) {
	  jclass clzclz = jenv->GetObjectClass(throwclz);
	  if (clzclz) {
	    jmethodID getNameMethodID = jenv->GetMethodID(clzclz, "getName", "()Ljava/lang/String;");
	    if (getNameMethodID) {
	      jstring jstr_classname = (jstring)(jenv->CallObjectMethod(throwclz, getNameMethodID));
              // Copy strings, since there is no guarantee that jenv will be active when handled
              if (jstr_classname) {
                JavaString jsclassname(jenv, jstr_classname);
                const char *classname = jsclassname.c_str(0);
                if (classname)
                  classname_ = copypath(classname);
              }
	    }
	  }
	}
      }

      JavaExceptionMessage exceptionmsg(jenv, throwable);
      msg_ = copystr(exceptionmsg.message(0));
    }

    // More general constructor for handling as a java.lang.RuntimeException
    DirectorException(const char *msg) : jenv_(0), throwable_(0), classname_(0), msg_(msg ? copystr(msg) : 0) {
    }

    ~DirectorException() throw() {
      delete[] classname_;
      delete[] msg_;
    }

    const char *what() const throw() {
      return msg_ ? msg_ : "Unspecified DirectorException message";
    }

    // Reconstruct and raise/throw the Java Exception that caused the DirectorException
    // Note that any error in the JNI exception handling results in a Java RuntimeException
    void throwException(JNIEnv *jenv) const {
      if (jenv) {
        if (jenv == jenv_ && throwable_) {
          // Throw original exception if not already pending
          jthrowable throwable = jenv->ExceptionOccurred();
          if (throwable && jenv->IsSameObject(throwable, throwable_) == JNI_FALSE) {
            jenv->ExceptionClear();
            throwable = 0;
          }
          if (!throwable)
            jenv->Throw(throwable_);
        } else {
          // Try and reconstruct original exception, but original stacktrace is not reconstructed
          jenv->ExceptionClear();

          jmethodID ctorMethodID = 0;
          jclass throwableclass = 0;
          if (classname_) {
            throwableclass = jenv->FindClass(classname_);
            if (throwableclass)
              ctorMethodID = jenv->GetMethodID(throwableclass, "<init>", "(Ljava/lang/String;)V");
          }

          if (ctorMethodID) {
            jenv->ThrowNew(throwableclass, what());
          } else {
            SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, what());
          }
        }
      }
    }

    // Deprecated - use throwException
    void raiseJavaException(JNIEnv *jenv) const {
      throwException(jenv);
    }

    // Create and throw the DirectorException
    static void raise(JNIEnv *jenv, jthrowable throwable) {
      throw DirectorException(jenv, throwable);
    }

  private:
    static char *copypath(const char *srcmsg) {
      char *target = copystr(srcmsg);
      for (char *c=target; *c; ++c) {
        if ('.' == *c)
          *c = '/';
      }
      return target;
    }

    static char *copystr(const char *srcmsg) {
      char *target = 0;
      if (srcmsg) {
	size_t msglen = strlen(srcmsg) + 1;
	target = new char[msglen];
	strncpy(target, srcmsg, msglen);
      }
      return target;
    }

    JNIEnv *jenv_;
    jthrowable throwable_;
    const char *classname_;
    const char *msg_;
  };

  // Helper method to determine if a Java throwable matches a particular Java class type
  // Note side effect of clearing any pending exceptions
  SWIGINTERN bool ExceptionMatches(JNIEnv *jenv, jthrowable throwable, const char *classname) {
    bool matches = false;

    if (throwable && jenv && classname) {
      // Exceptions need to be cleared for correct behavior.
      // The caller of ExceptionMatches should restore pending exceptions if desired -
      // the caller already has the throwable.
      jenv->ExceptionClear();

      jclass clz = jenv->FindClass(classname);
      if (clz) {
	jclass classclz = jenv->GetObjectClass(clz);
	jmethodID isInstanceMethodID = jenv->GetMethodID(classclz, "isInstance", "(Ljava/lang/Object;)Z");
	if (isInstanceMethodID) {
	  matches = jenv->CallBooleanMethod(clz, isInstanceMethodID, throwable) != 0;
	}
      }

#if defined(DEBUG_DIRECTOR_EXCEPTION)
      if (jenv->ExceptionCheck()) {
        // Typically occurs when an invalid classname argument is passed resulting in a ClassNotFoundException
        JavaExceptionMessage exc(jenv, jenv->ExceptionOccurred());
        std::cout << "Error: ExceptionMatches: class '" << classname << "' : " << exc.message() << std::endl;
      }
#endif
    }
    return matches;
  }
}

namespace Swig {
  namespace {
    jclass jclass_TauArgusJavaJNI = NULL;
    jmethodID director_method_ids[1];
  }
}

#if defined(SWIG_NOINCLUDE) || defined(SWIG_NOARRAYS)


static int SWIG_JavaArrayInBool (JNIEnv *jenv, jboolean **jarr, bool **carr, jbooleanArray input);
static void SWIG_JavaArrayArgoutBool (JNIEnv *jenv, jboolean *jarr, bool *carr, jbooleanArray input);
static jbooleanArray SWIG_JavaArrayOutBool (JNIEnv *jenv, bool *result, jsize sz);


static int SWIG_JavaArrayInSchar (JNIEnv *jenv, jbyte **jarr, signed char **carr, jbyteArray input);
static void SWIG_JavaArrayArgoutSchar (JNIEnv *jenv, jbyte *jarr, signed char *carr, jbyteArray input);
static jbyteArray SWIG_JavaArrayOutSchar (JNIEnv *jenv, signed char *result, jsize sz);


static int SWIG_JavaArrayInUchar (JNIEnv *jenv, jshort **jarr, unsigned char **carr, jshortArray input);
static void SWIG_JavaArrayArgoutUchar (JNIEnv *jenv, jshort *jarr, unsigned char *carr, jshortArray input);
static jshortArray SWIG_JavaArrayOutUchar (JNIEnv *jenv, unsigned char *result, jsize sz);


static int SWIG_JavaArrayInShort (JNIEnv *jenv, jshort **jarr, short **carr, jshortArray input);
static void SWIG_JavaArrayArgoutShort (JNIEnv *jenv, jshort *jarr, short *carr, jshortArray input);
static jshortArray SWIG_JavaArrayOutShort (JNIEnv *jenv, short *result, jsize sz);


static int SWIG_JavaArrayInUshort (JNIEnv *jenv, jint **jarr, unsigned short **carr, jintArray input);
static void SWIG_JavaArrayArgoutUshort (JNIEnv *jenv, jint *jarr, unsigned short *carr, jintArray input);
static jintArray SWIG_JavaArrayOutUshort (JNIEnv *jenv, unsigned short *result, jsize sz);


static int SWIG_JavaArrayInInt (JNIEnv *jenv, jint **jarr, int **carr, jintArray input);
static void SWIG_JavaArrayArgoutInt (JNIEnv *jenv, jint *jarr, int *carr, jintArray input);
static jintArray SWIG_JavaArrayOutInt (JNIEnv *jenv, int *result, jsize sz);


static int SWIG_JavaArrayInUint (JNIEnv *jenv, jlong **jarr, unsigned int **carr, jlongArray input);
static void SWIG_JavaArrayArgoutUint (JNIEnv *jenv, jlong *jarr, unsigned int *carr, jlongArray input);
static jlongArray SWIG_JavaArrayOutUint (JNIEnv *jenv, unsigned int *result, jsize sz);


static int SWIG_JavaArrayInLong (JNIEnv *jenv, jint **jarr, long **carr, jintArray input);
static void SWIG_JavaArrayArgoutLong (JNIEnv *jenv, jint *jarr, long *carr, jintArray input);
static jintArray SWIG_JavaArrayOutLong (JNIEnv *jenv, long *result, jsize sz);


static int SWIG_JavaArrayInUlong (JNIEnv *jenv, jlong **jarr, unsigned long **carr, jlongArray input);
static void SWIG_JavaArrayArgoutUlong (JNIEnv *jenv, jlong *jarr, unsigned long *carr, jlongArray input);
static jlongArray SWIG_JavaArrayOutUlong (JNIEnv *jenv, unsigned long *result, jsize sz);


static int SWIG_JavaArrayInLonglong (JNIEnv *jenv, jlong **jarr, jlong **carr, jlongArray input);
static void SWIG_JavaArrayArgoutLonglong (JNIEnv *jenv, jlong *jarr, jlong *carr, jlongArray input);
static jlongArray SWIG_JavaArrayOutLonglong (JNIEnv *jenv, jlong *result, jsize sz);


static int SWIG_JavaArrayInFloat (JNIEnv *jenv, jfloat **jarr, float **carr, jfloatArray input);
static void SWIG_JavaArrayArgoutFloat (JNIEnv *jenv, jfloat *jarr, float *carr, jfloatArray input);
static jfloatArray SWIG_JavaArrayOutFloat (JNIEnv *jenv, float *result, jsize sz);


static int SWIG_JavaArrayInDouble (JNIEnv *jenv, jdouble **jarr, double **carr, jdoubleArray input);
static void SWIG_JavaArrayArgoutDouble (JNIEnv *jenv, jdouble *jarr, double *carr, jdoubleArray input);
static jdoubleArray SWIG_JavaArrayOutDouble (JNIEnv *jenv, double *result, jsize sz);


#else


/* bool[] support */
static int SWIG_JavaArrayInBool (JNIEnv *jenv, jboolean **jarr, bool **carr, jbooleanArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetBooleanArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new bool[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = ((*jarr)[i] != 0);
  return 1;
}

static void SWIG_JavaArrayArgoutBool (JNIEnv *jenv, jboolean *jarr, bool *carr, jbooleanArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jboolean)carr[i];
  jenv->ReleaseBooleanArrayElements(input, jarr, 0);
}

static jbooleanArray SWIG_JavaArrayOutBool (JNIEnv *jenv, bool *result, jsize sz) {
  jboolean *arr;
  int i;
  jbooleanArray jresult = jenv->NewBooleanArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetBooleanArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jboolean)result[i];
  jenv->ReleaseBooleanArrayElements(jresult, arr, 0);
  return jresult;
}


/* signed char[] support */
static int SWIG_JavaArrayInSchar (JNIEnv *jenv, jbyte **jarr, signed char **carr, jbyteArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetByteArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new signed char[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (signed char)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutSchar (JNIEnv *jenv, jbyte *jarr, signed char *carr, jbyteArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jbyte)carr[i];
  jenv->ReleaseByteArrayElements(input, jarr, 0);
}

static jbyteArray SWIG_JavaArrayOutSchar (JNIEnv *jenv, signed char *result, jsize sz) {
  jbyte *arr;
  int i;
  jbyteArray jresult = jenv->NewByteArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetByteArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jbyte)result[i];
  jenv->ReleaseByteArrayElements(jresult, arr, 0);
  return jresult;
}


/* unsigned char[] support */
static int SWIG_JavaArrayInUchar (JNIEnv *jenv, jshort **jarr, unsigned char **carr, jshortArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetShortArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new unsigned char[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned char)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutUchar (JNIEnv *jenv, jshort *jarr, unsigned char *carr, jshortArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jshort)carr[i];
  jenv->ReleaseShortArrayElements(input, jarr, 0);
}

static jshortArray SWIG_JavaArrayOutUchar (JNIEnv *jenv, unsigned char *result, jsize sz) {
  jshort *arr;
  int i;
  jshortArray jresult = jenv->NewShortArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetShortArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jshort)result[i];
  jenv->ReleaseShortArrayElements(jresult, arr, 0);
  return jresult;
}


/* short[] support */
static int SWIG_JavaArrayInShort (JNIEnv *jenv, jshort **jarr, short **carr, jshortArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetShortArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new short[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (short)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutShort (JNIEnv *jenv, jshort *jarr, short *carr, jshortArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jshort)carr[i];
  jenv->ReleaseShortArrayElements(input, jarr, 0);
}

static jshortArray SWIG_JavaArrayOutShort (JNIEnv *jenv, short *result, jsize sz) {
  jshort *arr;
  int i;
  jshortArray jresult = jenv->NewShortArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetShortArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jshort)result[i];
  jenv->ReleaseShortArrayElements(jresult, arr, 0);
  return jresult;
}


/* unsigned short[] support */
static int SWIG_JavaArrayInUshort (JNIEnv *jenv, jint **jarr, unsigned short **carr, jintArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetIntArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new unsigned short[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned short)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutUshort (JNIEnv *jenv, jint *jarr, unsigned short *carr, jintArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];
  jenv->ReleaseIntArrayElements(input, jarr, 0);
}

static jintArray SWIG_JavaArrayOutUshort (JNIEnv *jenv, unsigned short *result, jsize sz) {
  jint *arr;
  int i;
  jintArray jresult = jenv->NewIntArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetIntArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jint)result[i];
  jenv->ReleaseIntArrayElements(jresult, arr, 0);
  return jresult;
}


/* int[] support */
static int SWIG_JavaArrayInInt (JNIEnv *jenv, jint **jarr, int **carr, jintArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetIntArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new int[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (int)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutInt (JNIEnv *jenv, jint *jarr, int *carr, jintArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];
  jenv->ReleaseIntArrayElements(input, jarr, 0);
}

static jintArray SWIG_JavaArrayOutInt (JNIEnv *jenv, int *result, jsize sz) {
  jint *arr;
  int i;
  jintArray jresult = jenv->NewIntArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetIntArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jint)result[i];
  jenv->ReleaseIntArrayElements(jresult, arr, 0);
  return jresult;
}


/* unsigned int[] support */
static int SWIG_JavaArrayInUint (JNIEnv *jenv, jlong **jarr, unsigned int **carr, jlongArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetLongArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new unsigned int[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned int)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutUint (JNIEnv *jenv, jlong *jarr, unsigned int *carr, jlongArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];
  jenv->ReleaseLongArrayElements(input, jarr, 0);
}

static jlongArray SWIG_JavaArrayOutUint (JNIEnv *jenv, unsigned int *result, jsize sz) {
  jlong *arr;
  int i;
  jlongArray jresult = jenv->NewLongArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetLongArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jlong)result[i];
  jenv->ReleaseLongArrayElements(jresult, arr, 0);
  return jresult;
}


/* long[] support */
static int SWIG_JavaArrayInLong (JNIEnv *jenv, jint **jarr, long **carr, jintArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetIntArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new long[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (long)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutLong (JNIEnv *jenv, jint *jarr, long *carr, jintArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];
  jenv->ReleaseIntArrayElements(input, jarr, 0);
}

static jintArray SWIG_JavaArrayOutLong (JNIEnv *jenv, long *result, jsize sz) {
  jint *arr;
  int i;
  jintArray jresult = jenv->NewIntArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetIntArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jint)result[i];
  jenv->ReleaseIntArrayElements(jresult, arr, 0);
  return jresult;
}


/* unsigned long[] support */
static int SWIG_JavaArrayInUlong (JNIEnv *jenv, jlong **jarr, unsigned long **carr, jlongArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetLongArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new unsigned long[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned long)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutUlong (JNIEnv *jenv, jlong *jarr, unsigned long *carr, jlongArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];
  jenv->ReleaseLongArrayElements(input, jarr, 0);
}

static jlongArray SWIG_JavaArrayOutUlong (JNIEnv *jenv, unsigned long *result, jsize sz) {
  jlong *arr;
  int i;
  jlongArray jresult = jenv->NewLongArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetLongArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jlong)result[i];
  jenv->ReleaseLongArrayElements(jresult, arr, 0);
  return jresult;
}


/* jlong[] support */
static int SWIG_JavaArrayInLonglong (JNIEnv *jenv, jlong **jarr, jlong **carr, jlongArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetLongArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new jlong[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (jlong)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutLonglong (JNIEnv *jenv, jlong *jarr, jlong *carr, jlongArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];
  jenv->ReleaseLongArrayElements(input, jarr, 0);
}

static jlongArray SWIG_JavaArrayOutLonglong (JNIEnv *jenv, jlong *result, jsize sz) {
  jlong *arr;
  int i;
  jlongArray jresult = jenv->NewLongArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetLongArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jlong)result[i];
  jenv->ReleaseLongArrayElements(jresult, arr, 0);
  return jresult;
}


/* float[] support */
static int SWIG_JavaArrayInFloat (JNIEnv *jenv, jfloat **jarr, float **carr, jfloatArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetFloatArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new float[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (float)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutFloat (JNIEnv *jenv, jfloat *jarr, float *carr, jfloatArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jfloat)carr[i];
  jenv->ReleaseFloatArrayElements(input, jarr, 0);
}

static jfloatArray SWIG_JavaArrayOutFloat (JNIEnv *jenv, float *result, jsize sz) {
  jfloat *arr;
  int i;
  jfloatArray jresult = jenv->NewFloatArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetFloatArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jfloat)result[i];
  jenv->ReleaseFloatArrayElements(jresult, arr, 0);
  return jresult;
}


/* double[] support */
static int SWIG_JavaArrayInDouble (JNIEnv *jenv, jdouble **jarr, double **carr, jdoubleArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = jenv->GetArrayLength(input);
  *jarr = jenv->GetDoubleArrayElements(input, 0);
  if (!*jarr)
    return 0; 
  *carr = new double[sz]; 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (double)(*jarr)[i];
  return 1;
}

static void SWIG_JavaArrayArgoutDouble (JNIEnv *jenv, jdouble *jarr, double *carr, jdoubleArray input) {
  int i;
  jsize sz = jenv->GetArrayLength(input);
  for (i=0; i<sz; i++)
    jarr[i] = (jdouble)carr[i];
  jenv->ReleaseDoubleArrayElements(input, jarr, 0);
}

static jdoubleArray SWIG_JavaArrayOutDouble (JNIEnv *jenv, double *result, jsize sz) {
  jdouble *arr;
  int i;
  jdoubleArray jresult = jenv->NewDoubleArray(sz);
  if (!jresult)
    return NULL;
  arr = jenv->GetDoubleArrayElements(jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jdouble)result[i];
  jenv->ReleaseDoubleArrayElements(jresult, arr, 0);
  return jresult;
}


#endif


#include <string>


#include "IProgressListener.h"
#include "TauArgus.h"



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "TauArgusJava_wrap.h"

SwigDirector_IProgressListener::SwigDirector_IProgressListener(JNIEnv *jenv) : IProgressListener(), Swig::Director(jenv) {
}

SwigDirector_IProgressListener::~SwigDirector_IProgressListener() {
  swig_disconnect_director_self("swigDirectorDisconnect");
}


void SwigDirector_IProgressListener::UpdateProgress(int Perc) {
  JNIEnvWrapper swigjnienv(this) ;
  JNIEnv * jenv = swigjnienv.getJNIEnv() ;
  jobject swigjobj = (jobject) NULL ;
  jint jPerc  ;
  
  if (!swig_override[0]) {
    SWIG_JavaThrowException(JNIEnvWrapper(this).getJNIEnv(), SWIG_JavaDirectorPureVirtual, "Attempted to invoke pure virtual method IProgressListener::UpdateProgress.");
    return;
  }
  swigjobj = swig_get_self(jenv);
  if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
    jPerc = (jint) Perc;
    jenv->CallStaticVoidMethod(Swig::jclass_TauArgusJavaJNI, Swig::director_method_ids[0], swigjobj, jPerc);
    jthrowable swigerror = jenv->ExceptionOccurred();
    if (swigerror) {
      Swig::DirectorException::raise(jenv, swigerror);
    }
    
  } else {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null upcall object in IProgressListener::UpdateProgress ");
  }
  if (swigjobj) jenv->DeleteLocalRef(swigjobj);
}

void SwigDirector_IProgressListener::swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global) {
  static struct {
    const char *mname;
    const char *mdesc;
    jmethodID base_methid;
  } methods[] = {
    {
      "UpdateProgress", "(I)V", NULL 
    }
  };
  
  static jclass baseclass = 0 ;
  
  if (swig_set_self(jenv, jself, swig_mem_own, weak_global)) {
    if (!baseclass) {
      baseclass = jenv->FindClass("tauargus/extern/dataengine/IProgressListener");
      if (!baseclass) return;
      baseclass = (jclass) jenv->NewGlobalRef(baseclass);
    }
    bool derived = (jenv->IsSameObject(baseclass, jcls) ? false : true);
    for (int i = 0; i < 1; ++i) {
      if (!methods[i].base_methid) {
        methods[i].base_methid = jenv->GetMethodID(baseclass, methods[i].mname, methods[i].mdesc);
        if (!methods[i].base_methid) return;
      }
      swig_override[i] = false;
      if (derived) {
        jmethodID methid = jenv->GetMethodID(jcls, methods[i].mname, methods[i].mdesc);
        swig_override[i] = (methid != methods[i].base_methid);
        jenv->ExceptionClear();
      }
    }
  }
}



#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_delete_1IProgressListener(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  IProgressListener *arg1 = (IProgressListener *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(IProgressListener **)&jarg1; 
  delete arg1;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_IProgressListener_1UpdateProgress(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IProgressListener *arg1 = (IProgressListener *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IProgressListener **)&jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->UpdateProgress(arg2);
}


SWIGEXPORT jlong JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_new_1IProgressListener(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  IProgressListener *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (IProgressListener *)new SwigDirector_IProgressListener(jenv);
  *(IProgressListener **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_IProgressListener_1director_1connect(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jswig_mem_own, jboolean jweak_global) {
  IProgressListener *obj = *((IProgressListener **)&objarg);
  (void)jcls;
  SwigDirector_IProgressListener *director = static_cast<SwigDirector_IProgressListener *>(obj);
  director->swig_connect_director(jenv, jself, jenv->GetObjectClass(jself), (jswig_mem_own == JNI_TRUE), (jweak_global == JNI_TRUE));
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_IProgressListener_1change_1ownership(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jtake_or_release) {
  IProgressListener *obj = *((IProgressListener **)&objarg);
  SwigDirector_IProgressListener *director = dynamic_cast<SwigDirector_IProgressListener *>(obj);
  (void)jcls;
  if (director) {
    director->swig_java_change_ownership(jenv, jself, jtake_or_release ? true : false);
  }
}


SWIGEXPORT jlong JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_new_1TauArgus(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  TauArgus *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (TauArgus *)new TauArgus();
  *(TauArgus **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_delete_1TauArgus(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(TauArgus **)&jarg1; 
  delete arg1;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetProgressListener(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  IProgressListener *arg2 = (IProgressListener *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = *(IProgressListener **)&jarg2; 
  (arg1)->SetProgressListener(arg2);
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetAllNonStructuralAsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->SetAllNonStructuralAsEmpty(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetSingleNonStructuralAsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  jint *jarr3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  result = (bool)(arg1)->SetSingleNonStructuralAsEmpty(arg2,arg3);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  delete [] arg3; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetSingleEmptyAsNonStructural(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  jint *jarr3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  result = (bool)(arg1)->SetSingleEmptyAsNonStructural(arg2,arg3);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  delete [] arg3; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetAllEmptyNonStructural(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->SetAllEmptyNonStructural(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetSecondaryFromHierarchicalAMPL(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  long temp4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  result = (bool)(arg1)->SetSecondaryFromHierarchicalAMPL((char const *)arg2,arg3,arg4);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteHierarchicalTableInAMPLFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jint jarg4, jdouble jarg5, jintArray jarg6) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  double arg5 ;
  long *arg6 = (long *) 0 ;
  long temp6 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (long)jarg4; 
  arg5 = (double)jarg5; 
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp6 = (long)0;
    arg6 = &temp6; 
  }
  result = (bool)(arg1)->WriteHierarchicalTableInAMPLFormat((char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp6;
    jenv->SetIntArrayRegion(jarg6, 0, 1, &jvalue);
  }
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetRoundedResponse(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (long)jarg3; 
  result = (bool)(arg1)->SetRoundedResponse((char const *)arg2,arg3);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1MaximumProtectionLevel(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jdouble jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (double)(arg1)->MaximumProtectionLevel(arg2);
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetProtectionLevelsForFrequencyTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long arg4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = (long)jarg4; 
  result = (bool)(arg1)->SetProtectionLevelsForFrequencyTable(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTableCellCost(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jdouble jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  double arg4 ;
  jint *jarr3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  arg4 = (double)jarg4; 
  result = (bool)(arg1)->SetTableCellCost(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  delete [] arg3; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetCellStatusStatistics(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jintArray jarg4, jintArray jarg5, jdoubleArray jarg6, jdoubleArray jarg7) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  long *arg5 = (long *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  jint *jarr3 ;
  jint *jarr4 ;
  jint *jarr5 ;
  jdouble *jarr6 ;
  jdouble *jarr7 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr4, (long **)&arg4, jarg4)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr5, (long **)&arg5, jarg5)) return 0; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr6, (double **)&arg6, jarg6)) return 0; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr7, (double **)&arg7, jarg7)) return 0; 
  result = (bool)(arg1)->GetCellStatusStatistics(arg2,arg3,arg4,arg5,arg6,arg7);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  SWIG_JavaArrayArgoutLong(jenv, jarr4, (long *)arg4, jarg4); 
  SWIG_JavaArrayArgoutLong(jenv, jarr5, (long *)arg5, jarg5); 
  SWIG_JavaArrayArgoutDouble(jenv, jarr6, (double *)arg6, jarg6); 
  SWIG_JavaArrayArgoutDouble(jenv, jarr7, (double *)arg7, jarg7); 
  delete [] arg3; 
  delete [] arg4; 
  delete [] arg5; 
  delete [] arg6; 
  delete [] arg7; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteTableInAMPLFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (long)jarg3; 
  result = (bool)(arg1)->WriteTableInAMPLFormat((char const *)arg2,arg3);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetInFileInfo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2, jstring jarg3) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  bool arg2 ;
  char *arg3 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return ;
  }
  (arg1)->SetInFileInfo(arg2,(char const *)arg3);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1ComputeCodesToIndices(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jobjectArray jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char **arg3 ;
  long *arg4 = (long *) 0 ;
  jint size3 ;
  jint *jarr4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    int i = 0;
    if (jarg3) {
      size3 = jenv->GetArrayLength(jarg3);
      
      arg3 = new char*[size3+1];
      
      
      
      for (i = 0; i<size3; i++) {
        jstring j_string = (jstring)jenv->GetObjectArrayElement(jarg3, i);
        const char *c_string = jenv->GetStringUTFChars(j_string, 0);
        
        arg3[i] = new char [strlen(c_string)+1];
        
        
        
        strcpy(arg3[i], c_string);
        jenv->ReleaseStringUTFChars(j_string, c_string);
        jenv->DeleteLocalRef(j_string);
      }
      arg3[i] = 0;
    } else {
      arg3 = 0;
      size3 = 0;
    }
  }
  if (!SWIG_JavaArrayInLong(jenv, &jarr4, (long **)&arg4, jarg4)) return 0; 
  result = (bool)(arg1)->ComputeCodesToIndices(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr4, (long *)arg4, jarg4); 
  {
    int i;
    for (i=0; i<size3; i++)
    
    delete[] arg3[i];
    delete[] arg3;
    
    
    
    
  }
  delete [] arg4; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1CheckRealizedLowerAndUpperValues(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (long)(arg1)->CheckRealizedLowerAndUpperValues(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetCTAValues(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jdouble jarg4, jdouble jarg5, jintArray jarg6) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  double arg4 ;
  double arg5 ;
  long *arg6 = (long *) 0 ;
  long temp6 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp6 = (long)0;
    arg6 = &temp6; 
  }
  result = (bool)(arg1)->SetCTAValues(arg2,arg3,arg4,arg5,arg6);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp6;
    jenv->SetIntArrayRegion(jarg6, 0, 1, &jvalue);
  }
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetRealizedLowerAndUpper(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jdouble jarg4, jdouble jarg5) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  double arg4 ;
  double arg5 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = (bool)(arg1)->SetRealizedLowerAndUpper(arg2,arg3,arg4,arg5);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1UndoSecondarySuppress(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  result = (bool)(arg1)->UndoSecondarySuppress(arg2,arg3);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTableSafetyInfo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3, jboolean jarg4, jintArray jarg5, jintArray jarg6, jboolean jarg7, jintArray jarg8, jintArray jarg9, jintArray jarg10, jboolean jarg11, jint jarg12, jint jarg13, jboolean jarg14, jint jarg15, jboolean jarg16, jdouble jarg17, jboolean jarg18, jint jarg19, jintArray jarg20) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool arg3 ;
  bool arg4 ;
  long *arg5 = (long *) 0 ;
  long *arg6 = (long *) 0 ;
  bool arg7 ;
  long *arg8 = (long *) 0 ;
  long *arg9 = (long *) 0 ;
  long *arg10 = (long *) 0 ;
  bool arg11 ;
  long arg12 ;
  long arg13 ;
  bool arg14 ;
  long arg15 ;
  bool arg16 ;
  double arg17 ;
  bool arg18 ;
  long arg19 ;
  long *arg20 = (long *) 0 ;
  jint *jarr5 ;
  jint *jarr6 ;
  jint *jarr8 ;
  jint *jarr9 ;
  jint *jarr10 ;
  long temp20 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = jarg4 ? true : false; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr5, (long **)&arg5, jarg5)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr6, (long **)&arg6, jarg6)) return 0; 
  arg7 = jarg7 ? true : false; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr8, (long **)&arg8, jarg8)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr9, (long **)&arg9, jarg9)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr10, (long **)&arg10, jarg10)) return 0; 
  arg11 = jarg11 ? true : false; 
  arg12 = (long)jarg12; 
  arg13 = (long)jarg13; 
  arg14 = jarg14 ? true : false; 
  arg15 = (long)jarg15; 
  arg16 = jarg16 ? true : false; 
  arg17 = (double)jarg17; 
  arg18 = jarg18 ? true : false; 
  arg19 = (long)jarg19; 
  {
    if (!jarg20) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg20) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp20 = (long)0;
    arg20 = &temp20; 
  }
  result = (bool)(arg1)->SetTableSafetyInfo(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr5, (long *)arg5, jarg5); 
  SWIG_JavaArrayArgoutLong(jenv, jarr6, (long *)arg6, jarg6); 
  SWIG_JavaArrayArgoutLong(jenv, jarr8, (long *)arg8, jarg8); 
  SWIG_JavaArrayArgoutLong(jenv, jarr9, (long *)arg9, jarg9); 
  SWIG_JavaArrayArgoutLong(jenv, jarr10, (long *)arg10, jarg10); 
  {
    jint jvalue = (jint)temp20;
    jenv->SetIntArrayRegion(jarg20, 0, 1, &jvalue);
  }
  delete [] arg5; 
  delete [] arg6; 
  delete [] arg8; 
  delete [] arg9; 
  delete [] arg10; 
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetVariableForTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jstring jarg4, jstring jarg5, jstring jarg6, jint jarg7, jboolean jarg8, jstring jarg9, jboolean jarg10, jboolean jarg11, jint jarg12) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  long arg7 ;
  bool arg8 ;
  char *arg9 = (char *) 0 ;
  bool arg10 ;
  bool arg11 ;
  long arg12 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  arg5 = 0;
  if (jarg5) {
    arg5 = (char *)jenv->GetStringUTFChars(jarg5, 0);
    if (!arg5) return 0;
  }
  arg6 = 0;
  if (jarg6) {
    arg6 = (char *)jenv->GetStringUTFChars(jarg6, 0);
    if (!arg6) return 0;
  }
  arg7 = (long)jarg7; 
  arg8 = jarg8 ? true : false; 
  arg9 = 0;
  if (jarg9) {
    arg9 = (char *)jenv->GetStringUTFChars(jarg9, 0);
    if (!arg9) return 0;
  }
  arg10 = jarg10 ? true : false; 
  arg11 = jarg11 ? true : false; 
  arg12 = (long)jarg12; 
  result = (bool)(arg1)->SetVariableForTable(arg2,arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,arg7,arg8,(char const *)arg9,arg10,arg11,arg12);
  jresult = (jboolean)result; 
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  if (arg5) jenv->ReleaseStringUTFChars(jarg5, (const char *)arg5);
  if (arg6) jenv->ReleaseStringUTFChars(jarg6, (const char *)arg6);
  if (arg9) jenv->ReleaseStringUTFChars(jarg9, (const char *)arg9);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1CompletedTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jstring jarg4, jboolean jarg5, jboolean jarg6, jboolean jarg7) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  char *arg4 = (char *) 0 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  long temp3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  arg5 = jarg5 ? true : false; 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  result = (bool)(arg1)->CompletedTable(arg2,arg3,(char const *)arg4,arg5,arg6,arg7);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetInTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jobjectArray jarg3, jdouble jarg4, jdouble jarg5, jdouble jarg6, jint jarg7, jdoubleArray jarg8, jdoubleArray jarg9, jint jarg10, jdouble jarg11, jdouble jarg12, jintArray jarg13, jintArray jarg14) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char **arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  long arg7 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  long arg10 ;
  double arg11 ;
  double arg12 ;
  long *arg13 = (long *) 0 ;
  long *arg14 = (long *) 0 ;
  jint size3 ;
  jdouble *jarr8 ;
  jdouble *jarr9 ;
  long temp13 ;
  long temp14 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    int i = 0;
    if (jarg3) {
      size3 = jenv->GetArrayLength(jarg3);
      
      arg3 = new char*[size3+1];
      
      
      
      for (i = 0; i<size3; i++) {
        jstring j_string = (jstring)jenv->GetObjectArrayElement(jarg3, i);
        const char *c_string = jenv->GetStringUTFChars(j_string, 0);
        
        arg3[i] = new char [strlen(c_string)+1];
        
        
        
        strcpy(arg3[i], c_string);
        jenv->ReleaseStringUTFChars(j_string, c_string);
        jenv->DeleteLocalRef(j_string);
      }
      arg3[i] = 0;
    } else {
      arg3 = 0;
      size3 = 0;
    }
  }
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (double)jarg6; 
  arg7 = (long)jarg7; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr8, (double **)&arg8, jarg8)) return 0; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr9, (double **)&arg9, jarg9)) return 0; 
  arg10 = (long)jarg10; 
  arg11 = (double)jarg11; 
  arg12 = (double)jarg12; 
  {
    if (!jarg13) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg13) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp13 = (long)0;
    arg13 = &temp13; 
  }
  {
    if (!jarg14) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg14) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp14 = (long)0;
    arg14 = &temp14; 
  }
  result = (bool)(arg1)->SetInTable(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutDouble(jenv, jarr8, (double *)arg8, jarg8); 
  SWIG_JavaArrayArgoutDouble(jenv, jarr9, (double *)arg9, jarg9); 
  {
    jint jvalue = (jint)temp13;
    jenv->SetIntArrayRegion(jarg13, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp14;
    jenv->SetIntArrayRegion(jarg14, 0, 1, &jvalue);
  }
  {
    int i;
    for (i=0; i<size3; i++)
    
    delete[] arg3[i];
    delete[] arg3;
    
    
    
    
  }
  delete [] arg8; 
  delete [] arg9; 
  
  
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1ThroughTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  (arg1)->ThroughTable();
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTotalsInCodeList(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jintArray jarg4, jintArray jarg5) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  long *arg5 = (long *) 0 ;
  jint *jarr3 ;
  long temp4 ;
  long temp5 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (long)0;
    arg5 = &temp5; 
  }
  result = (bool)(arg1)->SetTotalsInCodeList(arg2,arg3,arg4,arg5);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp5;
    jenv->SetIntArrayRegion(jarg5, 0, 1, &jvalue);
  }
  delete [] arg3; 
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetInCodeList(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jobjectArray jarg4, jintArray jarg5, jintArray jarg6) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  char **arg4 ;
  long *arg5 = (long *) 0 ;
  long *arg6 = (long *) 0 ;
  jint *jarr3 ;
  jint size4 ;
  long temp5 ;
  long temp6 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  {
    int i = 0;
    if (jarg4) {
      size4 = jenv->GetArrayLength(jarg4);
      
      arg4 = new char*[size4+1];
      
      
      
      for (i = 0; i<size4; i++) {
        jstring j_string = (jstring)jenv->GetObjectArrayElement(jarg4, i);
        const char *c_string = jenv->GetStringUTFChars(j_string, 0);
        
        arg4[i] = new char [strlen(c_string)+1];
        
        
        
        strcpy(arg4[i], c_string);
        jenv->ReleaseStringUTFChars(j_string, c_string);
        jenv->DeleteLocalRef(j_string);
      }
      arg4[i] = 0;
    } else {
      arg4 = 0;
      size4 = 0;
    }
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (long)0;
    arg5 = &temp5; 
  }
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp6 = (long)0;
    arg6 = &temp6; 
  }
  result = (bool)(arg1)->SetInCodeList(arg2,arg3,arg4,arg5,arg6);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  {
    jint jvalue = (jint)temp5;
    jenv->SetIntArrayRegion(jarg5, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp6;
    jenv->SetIntArrayRegion(jarg6, 0, 1, &jvalue);
  }
  delete [] arg3; 
  {
    int i;
    for (i=0; i<size4; i++)
    
    delete[] arg4[i];
    delete[] arg4;
    
    
    
    
  }
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteCellRecords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jint jarg4, jboolean jarg5, jboolean jarg6, jstring jarg7, jboolean jarg8, jboolean jarg9, jint jarg10) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  bool arg5 ;
  bool arg6 ;
  char *arg7 = (char *) 0 ;
  bool arg8 ;
  bool arg9 ;
  long arg10 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (long)jarg4; 
  arg5 = jarg5 ? true : false; 
  arg6 = jarg6 ? true : false; 
  arg7 = 0;
  if (jarg7) {
    arg7 = (char *)jenv->GetStringUTFChars(jarg7, 0);
    if (!arg7) return 0;
  }
  arg8 = jarg8 ? true : false; 
  arg9 = jarg9 ? true : false; 
  arg10 = (long)jarg10; 
  result = (bool)(arg1)->WriteCellRecords(arg2,(char const *)arg3,arg4,arg5,arg6,(char const *)arg7,arg8,arg9,arg10);
  jresult = (jboolean)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg7) jenv->ReleaseStringUTFChars(jarg7, (const char *)arg7);
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetTotalTabelSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jintArray jarg4) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  long temp3 ;
  long temp4 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return ;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return ;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return ;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return ;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  (arg1)->GetTotalTabelSize(arg2,arg3,arg4);
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  
  
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetSecondaryJJFORMAT(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jboolean jarg4, jintArray jarg5) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  bool arg4 ;
  long *arg5 = (long *) 0 ;
  long temp5 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = jarg4 ? true : false; 
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (long)0;
    arg5 = &temp5; 
  }
  result = (long)(arg1)->SetSecondaryJJFORMAT(arg2,(char const *)arg3,arg4,arg5);
  jresult = (jint)result; 
  {
    jint jvalue = (jint)temp5;
    jenv->SetIntArrayRegion(jarg5, 0, 1, &jvalue);
  }
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteJJFormat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jdouble jarg4, jdouble jarg5, jboolean jarg6, jboolean jarg7, jboolean jarg8) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  double arg4 ;
  double arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = jarg6 ? true : false; 
  arg7 = jarg7 ? true : false; 
  arg8 = jarg8 ? true : false; 
  result = (bool)(arg1)->WriteJJFormat(arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  jresult = (jboolean)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteCSV(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jboolean jarg4, jintArray jarg5, jint jarg6) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  bool arg4 ;
  long *arg5 = (long *) 0 ;
  long arg6 ;
  jint *jarr5 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = jarg4 ? true : false; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr5, (long **)&arg5, jarg5)) return 0; 
  arg6 = (long)jarg6; 
  result = (bool)(arg1)->WriteCSV(arg2,(char const *)arg3,arg4,arg5,arg6);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr5, (long *)arg5, jarg5); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  delete [] arg5; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetCellDistance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  jint *jarr3 ;
  long temp4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  result = (bool)(arg1)->GetCellDistance(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  delete [] arg3; 
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1PrepareCellDistance(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->PrepareCellDistance(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetSecondaryGHMITER(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jintArray jarg4, jboolean jarg5) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  bool arg5 ;
  long temp4 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  arg5 = jarg5 ? true : false; 
  result = (long)(arg1)->SetSecondaryGHMITER((char const *)arg2,arg3,arg4,arg5);
  jresult = (jint)result; 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteGHMITERDataCell(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jboolean jarg4) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  bool arg4 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = (long)jarg3; 
  arg4 = jarg4 ? true : false; 
  result = (long)(arg1)->WriteGHMITERDataCell((char const *)arg2,arg3,arg4);
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1WriteGHMITERSteuer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jstring jarg4, jint jarg5) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  long arg5 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  arg5 = (long)jarg5; 
  result = (long)(arg1)->WriteGHMITERSteuer((char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetVarCodeProperties(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jintArray jarg4, jintArray jarg5, jintArray jarg6, jintArray jarg7, jintArray jarg8, jobjectArray jarg9) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  long *arg5 = (long *) 0 ;
  long *arg6 = (long *) 0 ;
  long *arg7 = (long *) 0 ;
  long *arg8 = (long *) 0 ;
  char **arg9 = (char **) 0 ;
  long temp4 ;
  long temp5 ;
  long temp6 ;
  long temp7 ;
  long temp8 ;
  char *temp9 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (long)0;
    arg5 = &temp5; 
  }
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp6 = (long)0;
    arg6 = &temp6; 
  }
  {
    if (!jarg7) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg7) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp7 = (long)0;
    arg7 = &temp7; 
  }
  {
    if (!jarg8) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg8) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp8 = (long)0;
    arg8 = &temp8; 
  }
  {
    if (!jarg9) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg9) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    arg9 = &temp9; 
    *arg9 = 0;
  }
  result = (bool)(arg1)->GetVarCodeProperties(arg2,arg3,arg4,arg5,arg6,arg7,arg8,(char const **)arg9);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp5;
    jenv->SetIntArrayRegion(jarg5, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp6;
    jenv->SetIntArrayRegion(jarg6, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp7;
    jenv->SetIntArrayRegion(jarg7, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp8;
    jenv->SetIntArrayRegion(jarg8, 0, 1, &jvalue);
  }
  {
    jstring jnewstring = NULL;
    if (arg9) {
      jnewstring = jenv->NewStringUTF(*arg9);
    }
    jenv->SetObjectArrayElement(jarg9, 0, jnewstring); 
  }
  
  
  
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1UnsafeVariableCodes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jintArray jarg4, jintArray jarg5, jobjectArray jarg6, jintArray jarg7, jintArray jarg8) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  long *arg5 = (long *) 0 ;
  std::string *arg6 = (std::string *) 0 ;
  long *arg7 = (long *) 0 ;
  long *arg8 = (long *) 0 ;
  long temp4 ;
  long temp5 ;
  std::string strTemp6 ;
  long temp7 ;
  jint *jarr8 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (long)0;
    arg5 = &temp5; 
  }
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    
    jobject oInput = jenv->GetObjectArrayElement(jarg6, 0); 
    if ( NULL != oInput ) {
      jstring sInput = static_cast<jstring>( oInput );
      
      const char * arg6_pstr = (const char *)jenv->GetStringUTFChars(sInput, 0); 
      if (!arg6_pstr) return 0;
      strTemp6.assign( arg6_pstr );
      jenv->ReleaseStringUTFChars( sInput, arg6_pstr);  
    }
    
    arg6 = &strTemp6;
  }
  {
    if (!jarg7) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg7) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp7 = (long)0;
    arg7 = &temp7; 
  }
  if (!SWIG_JavaArrayInLong(jenv, &jarr8, (long **)&arg8, jarg8)) return 0; 
  result = (bool)(arg1)->UnsafeVariableCodes(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp5;
    jenv->SetIntArrayRegion(jarg5, 0, 1, &jvalue);
  }
  {
    jstring jStrTemp = jenv->NewStringUTF( strTemp6.c_str() );
    jenv->SetObjectArrayElement(jarg6, 0, jStrTemp); 
  }
  {
    jint jvalue = (jint)temp7;
    jenv->SetIntArrayRegion(jarg7, 0, 1, &jvalue);
  }
  SWIG_JavaArrayArgoutLong(jenv, jarr8, (long *)arg8, jarg8); 
  
  
  
  
  delete [] arg8; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetVarCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jintArray jarg4, jobjectArray jarg5, jintArray jarg6, jintArray jarg7) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  std::string *arg5 = (std::string *) 0 ;
  long *arg6 = (long *) 0 ;
  long *arg7 = (long *) 0 ;
  long temp4 ;
  std::string strTemp5 ;
  long temp6 ;
  long temp7 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    
    jobject oInput = jenv->GetObjectArrayElement(jarg5, 0); 
    if ( NULL != oInput ) {
      jstring sInput = static_cast<jstring>( oInput );
      
      const char * arg5_pstr = (const char *)jenv->GetStringUTFChars(sInput, 0); 
      if (!arg5_pstr) return 0;
      strTemp5.assign( arg5_pstr );
      jenv->ReleaseStringUTFChars( sInput, arg5_pstr);  
    }
    
    arg5 = &strTemp5;
  }
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp6 = (long)0;
    arg6 = &temp6; 
  }
  {
    if (!jarg7) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg7) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp7 = (long)0;
    arg7 = &temp7; 
  }
  result = (bool)(arg1)->GetVarCode(arg2,arg3,arg4,arg5,arg6,arg7);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  {
    jstring jStrTemp = jenv->NewStringUTF( strTemp5.c_str() );
    jenv->SetObjectArrayElement(jarg5, 0, jStrTemp); 
  }
  {
    jint jvalue = (jint)temp6;
    jenv->SetIntArrayRegion(jarg6, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp7;
    jenv->SetIntArrayRegion(jarg7, 0, 1, &jvalue);
  }
  
  
  
  
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetVarHierarchyDepth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool arg3 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = jarg3 ? true : false; 
  result = (long)(arg1)->GetVarHierarchyDepth(arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetHierarchicalCodelist(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jstring jarg4) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (long)(arg1)->SetHierarchicalCodelist(arg2,(char const *)arg3,(char const *)arg4);
  jresult = (jint)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetSecondaryHITAS(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long temp3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  result = (bool)(arg1)->SetSecondaryHITAS(arg2,arg3);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1PrepareHITAS(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jstring jarg4, jstring jarg5) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  arg5 = 0;
  if (jarg5) {
    arg5 = (char *)jenv->GetStringUTFChars(jarg5, 0);
    if (!arg5) return 0;
  }
  result = (bool)(arg1)->PrepareHITAS(arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  jresult = (jboolean)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  if (arg5) jenv->ReleaseStringUTFChars(jarg5, (const char *)arg5);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTableSafety(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3, jintArray jarg4, jintArray jarg5, jboolean jarg6, jintArray jarg7, jintArray jarg8, jintArray jarg9, jintArray jarg10, jintArray jarg11, jintArray jarg12, jintArray jarg13, jboolean jarg14, jboolean jarg15, jboolean jarg16, jboolean jarg17, jboolean jarg18, jboolean jarg19, jint jarg20, jdouble jarg21, jint jarg22, jintArray jarg23) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool arg3 ;
  long *arg4 = (long *) 0 ;
  long *arg5 = (long *) 0 ;
  bool arg6 ;
  long *arg7 = (long *) 0 ;
  long *arg8 = (long *) 0 ;
  long *arg9 = (long *) 0 ;
  long *arg10 = (long *) 0 ;
  long *arg11 = (long *) 0 ;
  long *arg12 = (long *) 0 ;
  long *arg13 = (long *) 0 ;
  bool arg14 ;
  bool arg15 ;
  bool arg16 ;
  bool arg17 ;
  bool arg18 ;
  bool arg19 ;
  long arg20 ;
  double arg21 ;
  long arg22 ;
  long *arg23 = (long *) 0 ;
  jint *jarr4 ;
  jint *jarr5 ;
  jint *jarr7 ;
  jint *jarr8 ;
  jint *jarr9 ;
  jint *jarr10 ;
  jint *jarr11 ;
  jint *jarr12 ;
  jint *jarr13 ;
  jint *jarr23 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = jarg3 ? true : false; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr4, (long **)&arg4, jarg4)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr5, (long **)&arg5, jarg5)) return 0; 
  arg6 = jarg6 ? true : false; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr7, (long **)&arg7, jarg7)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr8, (long **)&arg8, jarg8)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr9, (long **)&arg9, jarg9)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr10, (long **)&arg10, jarg10)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr11, (long **)&arg11, jarg11)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr12, (long **)&arg12, jarg12)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr13, (long **)&arg13, jarg13)) return 0; 
  arg14 = jarg14 ? true : false; 
  arg15 = jarg15 ? true : false; 
  arg16 = jarg16 ? true : false; 
  arg17 = jarg17 ? true : false; 
  arg18 = jarg18 ? true : false; 
  arg19 = jarg19 ? true : false; 
  arg20 = (long)jarg20; 
  arg21 = (double)jarg21; 
  arg22 = (long)jarg22; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr23, (long **)&arg23, jarg23)) return 0; 
  result = (bool)(arg1)->SetTableSafety(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21,arg22,arg23);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr4, (long *)arg4, jarg4); 
  SWIG_JavaArrayArgoutLong(jenv, jarr5, (long *)arg5, jarg5); 
  SWIG_JavaArrayArgoutLong(jenv, jarr7, (long *)arg7, jarg7); 
  SWIG_JavaArrayArgoutLong(jenv, jarr8, (long *)arg8, jarg8); 
  SWIG_JavaArrayArgoutLong(jenv, jarr9, (long *)arg9, jarg9); 
  SWIG_JavaArrayArgoutLong(jenv, jarr10, (long *)arg10, jarg10); 
  SWIG_JavaArrayArgoutLong(jenv, jarr11, (long *)arg11, jarg11); 
  SWIG_JavaArrayArgoutLong(jenv, jarr12, (long *)arg12, jarg12); 
  SWIG_JavaArrayArgoutLong(jenv, jarr13, (long *)arg13, jarg13); 
  SWIG_JavaArrayArgoutLong(jenv, jarr23, (long *)arg23, jarg23); 
  delete [] arg4; 
  delete [] arg5; 
  delete [] arg7; 
  delete [] arg8; 
  delete [] arg9; 
  delete [] arg10; 
  delete [] arg11; 
  delete [] arg12; 
  delete [] arg13; 
  delete [] arg23; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetTableCellValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jdoubleArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  double *arg4 = (double *) 0 ;
  double temp4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (double)0;
    arg4 = &temp4; 
  }
  result = (bool)(arg1)->GetTableCellValue(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  {
    jdouble jvalue = (jdouble)temp4;
    jenv->SetDoubleArrayRegion(jarg4, 0, 1, &jvalue);
  }
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetTableCellStatus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  long temp4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  result = (bool)(arg1)->GetTableCellStatus(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetTableCell(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jdoubleArray jarg4, jdoubleArray jarg5, jdoubleArray jarg6, jdoubleArray jarg7, jdoubleArray jarg8, jdoubleArray jarg9, jdoubleArray jarg10, jdoubleArray jarg11, jintArray jarg12, jintArray jarg13, jdoubleArray jarg14, jdoubleArray jarg15, jintArray jarg16, jdoubleArray jarg17, jintArray jarg18, jdoubleArray jarg19, jdoubleArray jarg20, jintArray jarg21, jintArray jarg22, jdoubleArray jarg23, jdoubleArray jarg24, jdoubleArray jarg25, jdoubleArray jarg26) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  double *arg10 = (double *) 0 ;
  double *arg11 = (double *) 0 ;
  long *arg12 = (long *) 0 ;
  long *arg13 = (long *) 0 ;
  double *arg14 = (double *) 0 ;
  double *arg15 = (double *) 0 ;
  long *arg16 = (long *) 0 ;
  double *arg17 = (double *) 0 ;
  long *arg18 = (long *) 0 ;
  double *arg19 = (double *) 0 ;
  double *arg20 = (double *) 0 ;
  long *arg21 = (long *) 0 ;
  long *arg22 = (long *) 0 ;
  double *arg23 = (double *) 0 ;
  double *arg24 = (double *) 0 ;
  double *arg25 = (double *) 0 ;
  double *arg26 = (double *) 0 ;
  jint *jarr3 ;
  double temp4 ;
  double temp5 ;
  double temp6 ;
  double temp7 ;
  double temp8 ;
  double temp9 ;
  jdouble *jarr10 ;
  jdouble *jarr11 ;
  long temp12 ;
  long temp13 ;
  jdouble *jarr14 ;
  double temp15 ;
  long temp16 ;
  jdouble *jarr17 ;
  jint *jarr18 ;
  double temp19 ;
  double temp20 ;
  long temp21 ;
  long temp22 ;
  double temp23 ;
  double temp24 ;
  double temp25 ;
  double temp26 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (double)0;
    arg4 = &temp4; 
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (double)0;
    arg5 = &temp5; 
  }
  {
    if (!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg6) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp6 = (double)0;
    arg6 = &temp6; 
  }
  {
    if (!jarg7) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg7) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp7 = (double)0;
    arg7 = &temp7; 
  }
  {
    if (!jarg8) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg8) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp8 = (double)0;
    arg8 = &temp8; 
  }
  {
    if (!jarg9) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg9) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp9 = (double)0;
    arg9 = &temp9; 
  }
  if (!SWIG_JavaArrayInDouble(jenv, &jarr10, (double **)&arg10, jarg10)) return 0; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr11, (double **)&arg11, jarg11)) return 0; 
  {
    if (!jarg12) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg12) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp12 = (long)0;
    arg12 = &temp12; 
  }
  {
    if (!jarg13) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg13) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp13 = (long)0;
    arg13 = &temp13; 
  }
  if (!SWIG_JavaArrayInDouble(jenv, &jarr14, (double **)&arg14, jarg14)) return 0; 
  {
    if (!jarg15) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg15) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp15 = (double)0;
    arg15 = &temp15; 
  }
  {
    if (!jarg16) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg16) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp16 = (long)0;
    arg16 = &temp16; 
  }
  if (!SWIG_JavaArrayInDouble(jenv, &jarr17, (double **)&arg17, jarg17)) return 0; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr18, (long **)&arg18, jarg18)) return 0; 
  {
    if (!jarg19) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg19) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp19 = (double)0;
    arg19 = &temp19; 
  }
  {
    if (!jarg20) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg20) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp20 = (double)0;
    arg20 = &temp20; 
  }
  {
    if (!jarg21) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg21) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp21 = (long)0;
    arg21 = &temp21; 
  }
  {
    if (!jarg22) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg22) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp22 = (long)0;
    arg22 = &temp22; 
  }
  {
    if (!jarg23) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg23) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp23 = (double)0;
    arg23 = &temp23; 
  }
  {
    if (!jarg24) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg24) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp24 = (double)0;
    arg24 = &temp24; 
  }
  {
    if (!jarg25) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg25) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp25 = (double)0;
    arg25 = &temp25; 
  }
  {
    if (!jarg26) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg26) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp26 = (double)0;
    arg26 = &temp26; 
  }
  result = (bool)(arg1)->GetTableCell(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21,arg22,arg23,arg24,arg25,arg26);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  {
    jdouble jvalue = (jdouble)temp4;
    jenv->SetDoubleArrayRegion(jarg4, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp5;
    jenv->SetDoubleArrayRegion(jarg5, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp6;
    jenv->SetDoubleArrayRegion(jarg6, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp7;
    jenv->SetDoubleArrayRegion(jarg7, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp8;
    jenv->SetDoubleArrayRegion(jarg8, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp9;
    jenv->SetDoubleArrayRegion(jarg9, 0, 1, &jvalue);
  }
  SWIG_JavaArrayArgoutDouble(jenv, jarr10, (double *)arg10, jarg10); 
  SWIG_JavaArrayArgoutDouble(jenv, jarr11, (double *)arg11, jarg11); 
  {
    jint jvalue = (jint)temp12;
    jenv->SetIntArrayRegion(jarg12, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp13;
    jenv->SetIntArrayRegion(jarg13, 0, 1, &jvalue);
  }
  SWIG_JavaArrayArgoutDouble(jenv, jarr14, (double *)arg14, jarg14); 
  {
    jdouble jvalue = (jdouble)temp15;
    jenv->SetDoubleArrayRegion(jarg15, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp16;
    jenv->SetIntArrayRegion(jarg16, 0, 1, &jvalue);
  }
  SWIG_JavaArrayArgoutDouble(jenv, jarr17, (double *)arg17, jarg17); 
  SWIG_JavaArrayArgoutLong(jenv, jarr18, (long *)arg18, jarg18); 
  {
    jdouble jvalue = (jdouble)temp19;
    jenv->SetDoubleArrayRegion(jarg19, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp20;
    jenv->SetDoubleArrayRegion(jarg20, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp21;
    jenv->SetIntArrayRegion(jarg21, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp22;
    jenv->SetIntArrayRegion(jarg22, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp23;
    jenv->SetDoubleArrayRegion(jarg23, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp24;
    jenv->SetDoubleArrayRegion(jarg24, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp25;
    jenv->SetDoubleArrayRegion(jarg25, 0, 1, &jvalue);
  }
  {
    jdouble jvalue = (jdouble)temp26;
    jenv->SetDoubleArrayRegion(jarg26, 0, 1, &jvalue);
  }
  delete [] arg3; 
  
  
  
  
  
  
  delete [] arg10; 
  delete [] arg11; 
  
  
  delete [] arg14; 
  
  
  delete [] arg17; 
  delete [] arg18; 
  
  
  
  
  
  
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jintArray jarg4, jboolean jarg5, jint jarg6, jint jarg7, jint jarg8, jint jarg9, jstring jarg10, jint jarg11, jdouble jarg12, jdouble jarg13, jint jarg14, jboolean jarg15) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  bool arg5 ;
  long arg6 ;
  long arg7 ;
  long arg8 ;
  long arg9 ;
  std::string arg10 ;
  long arg11 ;
  double arg12 ;
  double arg13 ;
  long arg14 ;
  bool arg15 ;
  jint *jarr4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr4, (long **)&arg4, jarg4)) return 0; 
  arg5 = jarg5 ? true : false; 
  arg6 = (long)jarg6; 
  arg7 = (long)jarg7; 
  arg8 = (long)jarg8; 
  arg9 = (long)jarg9; 
  if(!jarg10) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  } 
  const char *arg10_pstr = (const char *)jenv->GetStringUTFChars(jarg10, 0); 
  if (!arg10_pstr) return 0;
  (&arg10)->assign(arg10_pstr);
  jenv->ReleaseStringUTFChars(jarg10, arg10_pstr); 
  arg11 = (long)jarg11; 
  arg12 = (double)jarg12; 
  arg13 = (double)jarg13; 
  arg14 = (long)jarg14; 
  arg15 = jarg15 ? true : false; 
  result = (bool)(arg1)->SetTable(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr4, (long *)arg4, jarg4); 
  delete [] arg4; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetVariable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4, jint jarg5, jint jarg6, jstring jarg7, jstring jarg8, jstring jarg9, jboolean jarg10, jstring jarg11, jstring jarg12, jboolean jarg13, jboolean jarg14, jboolean jarg15, jboolean jarg16, jboolean jarg17, jboolean jarg18) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long arg4 ;
  long arg5 ;
  long arg6 ;
  char *arg7 = (char *) 0 ;
  char *arg8 = (char *) 0 ;
  char *arg9 = (char *) 0 ;
  bool arg10 ;
  char *arg11 = (char *) 0 ;
  char *arg12 = (char *) 0 ;
  bool arg13 ;
  bool arg14 ;
  bool arg15 ;
  bool arg16 ;
  bool arg17 ;
  bool arg18 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = (long)jarg4; 
  arg5 = (long)jarg5; 
  arg6 = (long)jarg6; 
  arg7 = 0;
  if (jarg7) {
    arg7 = (char *)jenv->GetStringUTFChars(jarg7, 0);
    if (!arg7) return 0;
  }
  arg8 = 0;
  if (jarg8) {
    arg8 = (char *)jenv->GetStringUTFChars(jarg8, 0);
    if (!arg8) return 0;
  }
  arg9 = 0;
  if (jarg9) {
    arg9 = (char *)jenv->GetStringUTFChars(jarg9, 0);
    if (!arg9) return 0;
  }
  arg10 = jarg10 ? true : false; 
  arg11 = 0;
  if (jarg11) {
    arg11 = (char *)jenv->GetStringUTFChars(jarg11, 0);
    if (!arg11) return 0;
  }
  arg12 = 0;
  if (jarg12) {
    arg12 = (char *)jenv->GetStringUTFChars(jarg12, 0);
    if (!arg12) return 0;
  }
  arg13 = jarg13 ? true : false; 
  arg14 = jarg14 ? true : false; 
  arg15 = jarg15 ? true : false; 
  arg16 = jarg16 ? true : false; 
  arg17 = jarg17 ? true : false; 
  arg18 = jarg18 ? true : false; 
  result = (bool)(arg1)->SetVariable(arg2,arg3,arg4,arg5,arg6,(char const *)arg7,(char const *)arg8,(char const *)arg9,arg10,(char const *)arg11,(char const *)arg12,arg13,arg14,arg15,arg16,arg17,arg18);
  jresult = (jboolean)result; 
  if (arg7) jenv->ReleaseStringUTFChars(jarg7, (const char *)arg7);
  if (arg8) jenv->ReleaseStringUTFChars(jarg8, (const char *)arg8);
  if (arg9) jenv->ReleaseStringUTFChars(jarg9, (const char *)arg9);
  if (arg11) jenv->ReleaseStringUTFChars(jarg11, (const char *)arg11);
  if (arg12) jenv->ReleaseStringUTFChars(jarg12, (const char *)arg12);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1DoActiveRecode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->DoActiveRecode(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetVarNumberOfCodes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  long temp3 ;
  long temp4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  result = (bool)(arg1)->GetVarNumberOfCodes(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetVarCodeActive(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jboolean jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  bool arg4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = jarg4 ? true : false; 
  result = (bool)(arg1)->SetVarCodeActive(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetStatusAndCostPerDim(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jdoubleArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  double *arg4 = (double *) 0 ;
  jint *jarr3 ;
  jdouble *jarr4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr4, (double **)&arg4, jarg4)) return 0; 
  result = (bool)(arg1)->GetStatusAndCostPerDim(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  SWIG_JavaArrayArgoutDouble(jenv, jarr4, (double *)arg4, jarg4); 
  delete [] arg3; 
  delete [] arg4; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTableCellStatus_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jint jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long arg4 ;
  jint *jarr3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  arg4 = (long)jarg4; 
  result = (bool)(arg1)->SetTableCellStatus(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  delete [] arg3; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetTableCellStatus_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jint jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long arg4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  arg4 = (long)jarg4; 
  result = (bool)(arg1)->SetTableCellStatus(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1UndoRecode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->UndoRecode(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1ExploreFile(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jintArray jarg3, jintArray jarg4, jintArray jarg5) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  char *arg2 = (char *) 0 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  long *arg5 = (long *) 0 ;
  long temp3 ;
  long temp4 ;
  long temp5 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp4 = (long)0;
    arg4 = &temp4; 
  }
  {
    if (!jarg5) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg5) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp5 = (long)0;
    arg5 = &temp5; 
  }
  result = (bool)(arg1)->ExploreFile((char const *)arg2,arg3,arg4,arg5);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp4;
    jenv->SetIntArrayRegion(jarg4, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp5;
    jenv->SetIntArrayRegion(jarg5, 0, 1, &jvalue);
  }
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1UnsafeVariable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  long *arg4 = (long *) 0 ;
  long temp3 ;
  jint *jarr4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  if (!SWIG_JavaArrayInLong(jenv, &jarr4, (long **)&arg4, jarg4)) return 0; 
  result = (bool)(arg1)->UnsafeVariable(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  SWIG_JavaArrayArgoutLong(jenv, jarr4, (long *)arg4, jarg4); 
  
  delete [] arg4; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetHierarchicalDigits(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jintArray jarg4) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  jint *jarr4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = (long)jarg3; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr4, (long **)&arg4, jarg4)) return 0; 
  result = (bool)(arg1)->SetHierarchicalDigits(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr4, (long *)arg4, jarg4); 
  delete [] arg4; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1CleanAll(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  (arg1)->CleanAll();
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1ApplyRecode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  TauArgus *arg1 = (TauArgus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  (arg1)->ApplyRecode();
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1DoRecode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jint jarg4, jstring jarg5, jstring jarg6, jintArray jarg7, jintArray jarg8, jintArray jarg9, jobjectArray jarg10) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  long *arg7 = (long *) 0 ;
  long *arg8 = (long *) 0 ;
  long *arg9 = (long *) 0 ;
  char **arg10 = (char **) 0 ;
  long temp7 ;
  long temp8 ;
  long temp9 ;
  char *temp10 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (long)jarg4; 
  arg5 = 0;
  if (jarg5) {
    arg5 = (char *)jenv->GetStringUTFChars(jarg5, 0);
    if (!arg5) return 0;
  }
  arg6 = 0;
  if (jarg6) {
    arg6 = (char *)jenv->GetStringUTFChars(jarg6, 0);
    if (!arg6) return 0;
  }
  {
    if (!jarg7) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg7) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp7 = (long)0;
    arg7 = &temp7; 
  }
  {
    if (!jarg8) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg8) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp8 = (long)0;
    arg8 = &temp8; 
  }
  {
    if (!jarg9) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg9) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp9 = (long)0;
    arg9 = &temp9; 
  }
  {
    if (!jarg10) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg10) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    arg10 = &temp10; 
    *arg10 = 0;
  }
  result = (bool)(arg1)->DoRecode(arg2,(char const *)arg3,arg4,(char const *)arg5,(char const *)arg6,arg7,arg8,arg9,(char const **)arg10);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp7;
    jenv->SetIntArrayRegion(jarg7, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp8;
    jenv->SetIntArrayRegion(jarg8, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp9;
    jenv->SetIntArrayRegion(jarg9, 0, 1, &jvalue);
  }
  {
    jstring jnewstring = NULL;
    if (arg10) {
      jnewstring = jenv->NewStringUTF(*arg10);
    }
    jenv->SetObjectArrayElement(jarg10, 0, jnewstring); 
  }
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg5) jenv->ReleaseStringUTFChars(jarg5, (const char *)arg5);
  if (arg6) jenv->ReleaseStringUTFChars(jarg6, (const char *)arg6);
  
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1ComputeTables(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2, jintArray jarg3) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long *arg2 = (long *) 0 ;
  long *arg3 = (long *) 0 ;
  long temp2 ;
  long temp3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  {
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg2) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp2 = (long)0;
    arg2 = &temp2; 
  }
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (long)0;
    arg3 = &temp3; 
  }
  result = (bool)(arg1)->ComputeTables(arg2,arg3);
  jresult = (jboolean)result; 
  {
    jint jvalue = (jint)temp2;
    jenv->SetIntArrayRegion(jarg2, 0, 1, &jvalue);
  }
  {
    jint jvalue = (jint)temp3;
    jenv->SetIntArrayRegion(jarg3, 0, 1, &jvalue);
  }
  
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetNumberTab(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->SetNumberTab(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetNumberVar(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (bool)(arg1)->SetNumberVar(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetMinimumCellValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jdoubleArray jarg3) {
  jdouble jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  double *arg3 = (double *) 0 ;
  double temp3 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  {
    if (!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if (jenv->GetArrayLength(jarg3) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    temp3 = (double)0;
    arg3 = &temp3; 
  }
  result = (double)(arg1)->GetMinimumCellValue(arg2,arg3);
  jresult = (jdouble)result; 
  {
    jdouble jvalue = (jdouble)temp3;
    jenv->SetDoubleArrayRegion(jarg3, 0, 1, &jvalue);
  }
  
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetProtectionLevelsForResponseTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jintArray jarg3, jdouble jarg4, jdouble jarg5) {
  jboolean jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  long *arg3 = (long *) 0 ;
  double arg4 ;
  double arg5 ;
  jint *jarr3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if (!SWIG_JavaArrayInLong(jenv, &jarr3, (long **)&arg3, jarg3)) return 0; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = (bool)(arg1)->SetProtectionLevelsForResponseTable(arg2,arg3,arg4,arg5);
  jresult = (jboolean)result; 
  SWIG_JavaArrayArgoutLong(jenv, jarr3, (long *)arg3, jarg3); 
  delete [] arg3; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetErrorString(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  result = (arg1)->GetErrorString(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1GetVersion(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  result = (arg1)->GetVersion();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetCellKeyValuesFreq(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jintArray jarg4, jintArray jarg5) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  std::string arg3 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  jint *jarr4 ;
  jint *jarr5 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  } 
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  (&arg3)->assign(arg3_pstr);
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  if (!SWIG_JavaArrayInInt(jenv, &jarr4, (int **)&arg4, jarg4)) return 0; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr5, (int **)&arg5, jarg5)) return 0; 
  result = (int)(arg1)->SetCellKeyValuesFreq(arg2,arg3,arg4,arg5);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutInt(jenv, jarr4, (int *)arg4, jarg4); 
  SWIG_JavaArrayArgoutInt(jenv, jarr5, (int *)arg5, jarg5); 
  delete [] arg4; 
  delete [] arg5; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_TauArgus_1SetCellKeyValuesCont(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jstring jarg4, jstring jarg5, jint jarg6, jboolean jarg7, jboolean jarg8, jboolean jarg9, jdouble jarg10, jstring jarg11, jdouble jarg12, jdouble jarg13, jdouble jarg14, jdouble jarg15, jdoubleArray jarg16, jdouble jarg17) {
  jint jresult = 0 ;
  TauArgus *arg1 = (TauArgus *) 0 ;
  long arg2 ;
  std::string arg3 ;
  std::string arg4 ;
  std::string arg5 ;
  int arg6 ;
  bool arg7 ;
  bool arg8 ;
  bool arg9 ;
  double arg10 ;
  std::string arg11 ;
  double arg12 ;
  double arg13 ;
  double arg14 ;
  double arg15 ;
  double *arg16 = (double *) 0 ;
  double arg17 ;
  jdouble *jarr16 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TauArgus **)&jarg1; 
  arg2 = (long)jarg2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  } 
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  (&arg3)->assign(arg3_pstr);
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  } 
  const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0); 
  if (!arg4_pstr) return 0;
  (&arg4)->assign(arg4_pstr);
  jenv->ReleaseStringUTFChars(jarg4, arg4_pstr); 
  if(!jarg5) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  } 
  const char *arg5_pstr = (const char *)jenv->GetStringUTFChars(jarg5, 0); 
  if (!arg5_pstr) return 0;
  (&arg5)->assign(arg5_pstr);
  jenv->ReleaseStringUTFChars(jarg5, arg5_pstr); 
  arg6 = (int)jarg6; 
  arg7 = jarg7 ? true : false; 
  arg8 = jarg8 ? true : false; 
  arg9 = jarg9 ? true : false; 
  arg10 = (double)jarg10; 
  if(!jarg11) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  } 
  const char *arg11_pstr = (const char *)jenv->GetStringUTFChars(jarg11, 0); 
  if (!arg11_pstr) return 0;
  (&arg11)->assign(arg11_pstr);
  jenv->ReleaseStringUTFChars(jarg11, arg11_pstr); 
  arg12 = (double)jarg12; 
  arg13 = (double)jarg13; 
  arg14 = (double)jarg14; 
  arg15 = (double)jarg15; 
  if (!SWIG_JavaArrayInDouble(jenv, &jarr16, (double **)&arg16, jarg16)) return 0; 
  arg17 = (double)jarg17; 
  result = (int)(arg1)->SetCellKeyValuesCont(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutDouble(jenv, jarr16, (double *)arg16, jarg16); 
  delete [] arg16; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_tauargus_extern_dataengine_TauArgusJavaJNI_swig_1module_1init(JNIEnv *jenv, jclass jcls) {
  int i;
  
  static struct {
    const char *method;
    const char *signature;
  } methods[1] = {
    {
      "SwigDirector_IProgressListener_UpdateProgress", "(Ltauargus/extern/dataengine/IProgressListener;I)V" 
    }
  };
  Swig::jclass_TauArgusJavaJNI = (jclass) jenv->NewGlobalRef(jcls);
  if (!Swig::jclass_TauArgusJavaJNI) return;
  for (i = 0; i < (int) (sizeof(methods)/sizeof(methods[0])); ++i) {
    Swig::director_method_ids[i] = jenv->GetStaticMethodID(jcls, methods[i].method, methods[i].signature);
    if (!Swig::director_method_ids[i]) return;
  }
}


#ifdef __cplusplus
}
#endif

